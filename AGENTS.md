# AGENTS.md

This document provides guidelines for AI coding agents to create Robot Framework packages that integrate with BPMN process orchestration using [purjo](https://pypi.org/project/purjo/) and [Operaton](https://operaton.org/) BPM engine.


## Project Overview

Robot Framework packages (also called "robot packages" or "bots") are units of automation that can be orchestrated by a BPMN process engine. Each package contains:

- Robot Framework test/task files (`.robot`)
- Optional Python keyword libraries (`.py`)
- Configuration in `pyproject.toml`
- Dependencies managed via `uv`


## MCP Server Integration

Projects using these robot packages have access to `rf-mcp` (Robot Framework MCP Server). Use the MCP tools to:

- Discover available Robot Framework keywords with `find_keywords`
- Get keyword documentation with `get_keyword_info`
- Execute and validate Robot Framework code interactively
- Build test suites from validated execution steps

See [rf-mcp documentation](https://github.com/manykarim/rf-mcp) for complete tool reference.


## Package Structure

A minimal robot package should include:

```
my-package/
├── pyproject.toml           # Dependencies and topic mappings
├── uv.lock                  # Lock file (generated by uv)
├── README.md                # Package documentation
├── .wrapignore              # Files to exclude from packaging
├── my-tasks.robot           # Robot Framework tasks
└── MyLibrary.py             # Optional Python keyword library
```


## Creating a New Package

### Step 1: Initialize with `pur init`

**IMPORTANT**: Before running `pur init`, ensure the target directory is empty. The command will fail or produce unexpected results if files already exist.

```console
$ mkdir my-package
$ cd my-package
# Verify directory is empty
$ ls -la
# Should show only . and ..
$ pur init
```

This creates the base structure with example files including:
- `hello.bpmn` - Example BPMN process
- `hello.robot` - Example Robot Framework task
- `Hello.py` - Example Python keyword library
- `pyproject.toml` - Project configuration
- `uv.lock` - Dependency lock file

### Step 2: Configure pyproject.toml

The `pyproject.toml` defines Python dependencies and maps BPMN topics to Robot Framework tests/tasks:

```toml
[project]
name = "my-package"
version = "0.1.0"
description = "Description of the package"
readme = "README.md"
requires-python = ">=3.12"
dependencies = [
    "robotframework>=7.4.1",
]

[tool.purjo.topics]
# Maps BPMN topic names to Robot Framework test/task names
"My Topic in BPMN" = { name = "My Task Name in Robot" }
```

#### Topic Configuration Options

- `name`: The Robot Framework test/task name to execute (passed as `-t` argument). Use `"*"` to run all tests/tasks.
- `on-fail`: How to handle failures:
  - `"FAIL"` (default): Creates an incident in the engine for manual handling
  - `"COMPLETE"`: Completes successfully but sets `errorCode` and `errorMessage` variables
  - `"ERROR"`: Reports as BPMN error (can be caught by error boundary events)
- `process-variables`: If `true`, passes all process variables to Robot Framework (default: `false`)

```toml
[tool.purjo.topics."My Topic"]
name = "My Task"
on-fail = "ERROR"
process-variables = true
```

### Step 3: Add Dependencies

Use `uv` to manage Python dependencies:

```console
$ uv add requests
```


## Robot Framework Conventions

### Variable Declarations

Define default values for expected input variables:

```robotframework
*** Variables ***
${BPMN:TASK}        local     # Scope placeholder for task-level output
${BPMN:PROCESS}     local     # Scope placeholder for process-level output

${input_var}        ${None}   # Expected input from BPMN
@{list_input}       ${None}   # List input
&{dict_input}       &{EMPTY}  # Dictionary input
```

### Returning Variables to BPMN

Use the special scope placeholders to return variables:

```robotframework
*** Tasks ***
My Task
    # Return variable to task scope (requires output mapping in BPMN)
    VAR    ${result}    ${computed_value}    scope=${BPMN:TASK}

    # Return variable directly to process scope
    VAR    ${result}    ${computed_value}    scope=${BPMN:PROCESS}
```

**Important**: Variables with `scope=${BPMN:PROCESS}` cannot override input-mapped variables. Use BPMN output mapping for those.

### Python Keyword Libraries

Create custom keyword libraries using Robot Framework decorators.

**CRITICAL**: Always import AND use BOTH the `@library` AND `@keyword` decorators. Missing either decorator will cause the library or keywords to not be recognized:

```python
# CORRECT: Import both decorators
from robot.api.deco import keyword, library


@library()  # Required: marks class as a Robot Framework library
class MyLibrary:
    @keyword()  # Required: marks method as a keyword - DO NOT FORGET THIS
    def my_keyword(self, arg1: str, arg2: int) -> str:
        """Keyword documentation here."""
        return f"Result: {arg1} - {arg2}"

    @keyword()  # Every public keyword method needs this decorator
    def another_keyword(self, value: str) -> str:
        """Another keyword."""
        return value.upper()
```

**Common mistake**: Forgetting the `@keyword()` decorator on methods. Without it, the method will not be available as a Robot Framework keyword.

Import in Robot Framework:

```robotframework
*** Settings ***
Library    MyLibrary.py
```


## BPMN Modeling

### External Service Tasks

Robot Framework tasks are triggered by external service tasks in BPMN:

1. Add a Service Task to the BPMN diagram
2. Set Implementation Type to `External`
3. Set Topic to match the topic in `pyproject.toml`

**Tip**: Use "robot" in the task ID (e.g., `Robot_MyTask`) for visual robot icon in the modeler.

### Input/Output Mapping

Configure in BPMN properties panel:

**Inputs** (process → task variables):
```
name: input_var
value: ${processVariable}
```

**Outputs** (task → process variables):
```
name: processOutput
value: ${execution.getVariable("result")}
```

For file variables, use:
```
${execution.getVariableTyped("filename")}
```

### Gateway Conditions

Use JUEL expressions for conditional flows:

```
${result == "success"}
${count > 10}
${errorCode != null}
```

### User Tasks with Dynamic Forms

When creating demo or interactive processes, enhance the default BPMN from `pur init` by adding a User Task before the robot task. This allows manual submission of input values through Operaton Tasklist.

**When to add User Tasks:**
- Demo processes where users should provide input values
- Testing robot tasks with different inputs without redeploying
- Interactive workflows requiring human input before automation

**Setting up User Task with Generated Form (Camunda 7 Dynamic Forms):**

1. Add a User Task before the robot Service Task in your BPMN
2. In properties panel, set **Form Type** to `Generated Task Form`
3. Add form fields that match your robot's expected input variables:

```
Form Field ID: message
Type: string
Label: Message to process

Form Field ID: count  
Type: long
Label: Number of iterations

Form Field ID: enabled
Type: boolean
Label: Enable feature
```

**Example BPMN flow with User Task:**

```
[Start Event] → [User Task: Provide Input] → [Robot Task: Process Data] → [End Event]
```

The User Task will display a form in Operaton Tasklist where users can enter values. Upon form submission, these values become process variables available to the subsequent robot task through input mapping.

**Tip**: Match the Form Field IDs exactly to the variable names expected by your robot task to simplify input mapping.


## Testing Robot Packages

### Using the purjo Library

Test tasks locally without a running BPM engine:

```robotframework
*** Settings ***
Library    purjo
Library    Collections

*** Test Cases ***
Test My Task
    ${inputs}=    Create Dictionary    input_var=test_value
    ${outputs}=   Get Output Variables    .    My Topic    ${inputs}
    Should Be Equal    ${outputs}[result]    expected_value
```

#### Get Output Variables Arguments

- `path`: Path to robot package (`.` for current directory)
- `topic`: BPMN topic name from `pyproject.toml`
- `variables`: Dictionary of input variables
- `secrets`: (Optional) Dictionary of secrets

### Testing with Secrets

```robotframework
*** Test Cases ***
Test With Secrets
    ${inputs}=    Create Dictionary    name=John
    ${secrets}=   Create Dictionary    api_key=secret123
    ${outputs}=   Get Output Variables    .    My Topic    ${inputs}    ${secrets}
```


## Secrets Management

### File Provider

```toml
[tool.purjo.secrets.default]
provider = "file"
path = "secrets.json"
```

```json
{
  "api_key": "my-secret-key"
}
```

### Vault Provider

```toml
[tool.purjo.secrets.prod]
provider = "vault"
path = "secret/my-app"
mount-point = "secret"
```

**Warning**: Never commit secrets files to version control. Add to `.gitignore`.


## Error Handling

### BPMN Error Boundary Events

When using `on-fail = "ERROR"`, failures can be caught with error boundary events:

```robotframework
*** Tasks ***
My Task
    ${result}=    Some Operation
    IF    not ${result}
        ${error}=    Catenate    SEPARATOR=\n
        ...    ValidationError
        ...    The operation failed validation
        FAIL    ${error}
    END
```

The first line becomes `errorCode`, the rest becomes `errorMessage`.


## Running and Deploying

### Development Workflow

```console
# Start Operaton engine (if using playground)
$ make start

# Deploy BPMN and start process instance
$ pur run my-process.bpmn

# Serve the robot package
$ pur serve .
```

### Starting with Variables

```console
$ pur run my-process.bpmn --variables '{"key": "value"}'
$ pur run my-process.bpmn --variables input.json
```

### Packaging for Deployment

```console
# Create robot.zip
$ pur wrap

# Create offline-capable package (includes dependency cache)
$ pur wrap --offline
```


## Code Style Guidelines

- Use descriptive names for tests/tasks matching business domain terms
- Name events to describe business state
- Name tasks with verbs describing actions
- Keep robot files focused on single responsibilities
- Use Python libraries for complex logic
- Document keywords with docstrings
- Use type hints in Python code


## Common Patterns

### Conditional Task Completion

```robotframework
*** Tasks ***
Process Data
    ${result}=    Process Something
    IF    ${result.needs_review}
        VAR    ${requireManual}    ${True}    scope=${BPMN:PROCESS}
    ELSE
        VAR    ${requireManual}    ${False}    scope=${BPMN:PROCESS}
    END
```

### File Variable Handling

```robotframework
*** Variables ***
${BPMN:TASK}    local
${output}       ${CURDIR}/output.pdf

*** Tasks ***
Create Document
    Create PDF    ${output}    ${message}
    VAR    ${output}    ${output}    scope=${BPMN:TASK}
```

### Retry with Random Simulation

```robotframework
*** Settings ***
Library    random

*** Tasks ***
Simulate External Service
    ${success}=    randint    ${0}    ${10}
    IF    ${success} < 3
        FAIL    Service temporarily unavailable
    END
    Log    Service call successful
```


## Troubleshooting

### Common Issues

1. **Variables not passed to robot**: Check input mapping in BPMN and `process-variables` setting
2. **Output not returned to BPMN**: Verify output mapping and scope usage
3. **Task not picked up**: Confirm topic name matches exactly between BPMN and `pyproject.toml`
4. **Dependencies missing**: Run `uv sync` after modifying `pyproject.toml`


## Environment Variables

- `ENGINE_REST_BASE_URL`: Operaton REST API URL (default: `http://localhost:8080/engine-rest`)
- `ENGINE_REST_AUTHORIZATION`: Basic auth header value
- `VAULT_ADDR`, `VAULT_TOKEN`: For HashiCorp Vault secrets provider


## References

- [Robot Framework Documentation](https://robotframework.org/)
- [Operaton Documentation](https://docs.operaton.org/)
- [purjo on PyPI](https://pypi.org/project/purjo/)
- [rf-mcp on PyPI](https://pypi.org/project/rf-mcp/)
- [BPMN 2.0 Specification](https://www.omg.org/spec/BPMN/2.0/)
